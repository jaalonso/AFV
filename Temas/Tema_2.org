#+TITLE: Tema 2: Programación y demostración
#+LANGUAGE: es

* Contenido                                                        :TOC_2_gh:
 - [[#visión-panorámica-de-isabellehol][Visión panorámica de Isabelle/HOL]]
   - [[#hol-lógica-de-orden-superior][HOL: Lógica de orden superior]]
   - [[#tipos-y-términos-][Tipos y términos ]]
   - [[#los-tipos-bool-nat-y-list][Los tipos bool, nat y list]]
   - [[#tipos-numéricos][Tipos numéricos]]
   - [[#resumen][Resumen]]
 - [[#definiciones-de-tipos-y-funciones][Definiciones de tipos y funciones]]
   - [[#definiciones-de-tipos][Definiciones de tipos]]

* Visión panorámica de Isabelle/HOL

** HOL: Lógica de orden superior

+ Las siglas HOL (del inglés, /Higher-Order Logic/) significa "Lógica de orden
  superior". 

+ Ecuación fundamental de HOL:
  + HOL = Programación funcional + Lógica

+ HOL, como lenguaje de programación, dispone de
  + operadores lógicos
  + funciones recursivas
  + funciones de orden superior
  + tipos de datos

+ Fórmulas de HOL:
  + Inicialmente sólo consideraremos ecuaciones de la forma ~t = s~ donde ~t~ y
    ~s~ son términos.
  + Más adelante se añadirán conectivas y cuantificadores.

** Tipos y términos 

+ Sintaxis de tipos
  : τ ::= (τ)
  :     | bool | nat | int ...    tipos básicos 
  :     | 'a | 'b | ...           variables de tipos
  :     | τ ⇒ τ                   funciones
  :     | τ × τ                   pares (en ASCII: *)
  :     | τ list                  listas
  :     | τ set                   conjuntos
  :     | ...                     tipos definidos por el usuario


+ Sintaxis de términos (del lambda cálculo)
  : t ::= (t)
  :     | a       constante o variable 
  :     | t t     aplicación de funciones
  :     | λx. t   abstracción de funciones
  :     | ...     azúcar sintática

+ Tipado de términos
  + Todos los términos tienen un tipos.
  + 
    ~t :: τ~ significa que "el tipo de ~t~ es ~τ~

+ Inferencia de tipo:
  + Regla de tipos para aplicaciones
    : t :: τ₁ ⇒ τ₂    u :: τ₁
    : ——————————————————————–
    :        t u :: t₂
  + Isabelle automáticamente calcula el tipo de las variables de los
    términos. Esto se llama *inferencia de tipos*.
  + A veces no es posible por la presencia de funciones /sobrecargadas/. 
  + Las ambigüedades se resuelven con *anotaciones de tipo*. Por ejemplo, 
    ~f (x::nat)~. 

+ Currificación:
  + Definición curryficada 
    ~f :: τ₁ ⇒ τ₂ ⇒ τ~ 
  + Definición cartesiana 
    ~g :: τ₁ × τ₂ ⇒ τ~ 

+ Azúcar sintáctica
  + Operadores infijos:
    ~+, -, *, #, @, ...~
  + Operadores mixfijos:
   ~if _ then _ else _, case _ of, ...~
  + Los prefijos tienen prioridad sobre los infijos
    + ~f x + y ≡ (f x) + y~
    + ~f x + y ≢ f (x + y)~
  + Las expresiones con ~if~ o ~case~ se tienen que escribir entre paréntesis. 

+ Teorías de Isabelle
  + Las teorías de Isabelle son análogas a los módulos de Haskell.
  + La sintaxis de una teoría de Isabelle es
    : theory T
    : imports T₁ ... Tₙ
    : begin
    : (definiciones, teoremas. demostraciones, ...)*
    : end
  + ~T~ es el nombre de la teoría (y el nombre de su fichero tiene que ser
    ~T.thy~)
  + ~T₁, ..., Tₙ~ son la teorías importadas.
  + La importación de toerías es transitiva.
  + El cuerpo de la teoría se compone de definiciones,
    teoremas. demostraciones, ... 
  + Usualmente importaremos sólo la teoría ~Main~.

+ Sintaxis concreta:
  + En la teorías se tiene que escribir entre dobles comillas los tipos, los
    términos y las fórmulas.
  + Una posible excepción son los identificadores simples.

+ El entorno jEdit
  + El editor de Isabelle está construido sobre jEdit.
  + Reconoce las teorías de Isabelle por su extensión (~.thy~). 
  + Procesa las teorías de forma síncrona.

+ Demo: [[./T2_Introduccion.thy][T2_Introduccion.thy]].
  + Comentarios 
  + Inferencia de tipo 
  + Evaluación de términos 
  + Ejemplos de sobrecarga 
  + Ejemplos de errores de tipo 

** Los tipos bool, nat y list

+ El tipo ~bool~
  + ~bool~ es el tipo de los booleanos
  + Está definido por \\
    ~datatype bool = True | False~
  + Funciones predefinidas: \\
    ~∧, ∨, →, ... :: bool ⇒ bool ⇒ bool~
  + Las *fórmulas* son los términos de tipo ~bool~.
  + El bicondicional es ~=~.   

+ El tipo ~nat~
  + ~nat~ es el tipo de los números naturales.
  + Está definido por \\
    ~datatype nat = 0 | Suc nat~
  + Ejemplos de valores de tipo ~nat~
    ~0, Suc 0, Suc (Suc 0), ...~
  + Funciones predefinidas \\
    ~+, ∗, ... :: nat ⇒ nat ⇒ nat~    
  + Los números y las operaciones aritméticas están sobrecargadas: \\
    + 
      ~0, 1, 2, ... :: 'a~ 
    + 
      ~+ :: 'a ⇒ 'a ⇒ 'a~ 
  + Para resolver las ambigüedades se usan anotaciones:
    ~1::nat, x + (y::nat)~
  + Demo: [[./T2_Demo_Nat.thy][T2_Demo_Nat.thy]].
    + Ejemplo de definición recursiva sobre los naturales: suma.
    + Ejemplo de demostración pos inducción sobre los naturales. 
 
+ El tipo ~list~
  + 'a list es el tipo de las listas con elementos de tipo 'a.
  + Está definido por \\
    ~datatype 'a list = Nil | Cons 'a ('a list)~
  + Ejemplos listas: 
    ~Nil, Cons 1 Nil, Cons 1 (Cons 2 Nil), ...~
  + Azúcar sintáctica:
    + ~[]~ es una abreviatura de ~Nil~ (la lista vacía).
    + ~x#xs~ es una abreviatura de ~Cons x xs~ (la lista cuyo primer elemento
      es ~x~ y su resto es ~xs~).
    + ~[x1,...,xn]~ es una abreviatura de ~x1 # (x2 #...# (xn # []))~ (la lista
      cuyos elementos son ~x1~, ..., ~xn~).
    + Esquema de inducción sobre listas: Para probar que todas las listas
      cumplen una propiedad P, basta probar que
      + P([])
      + si P(xs) entonces P(x#xs), para todos x, xs.
    + Demo: [[./T2_Demo_Lista.thy][T2_Demo_Lista.thy]].
      + El tipo de las listas.
      + Funciones sobre listas: conc e inversa.
      + Ejemplo de búqueda descendente de la demostración de 
        "inversa (inversa xs) = xs".
    + Funciones predefinidas sobre listas: ~length~, ~@~, ~rev~, ~map~, ...

** Tipos numéricos

+ Tipos numéricos: nat, int, real
  + nat es el tipo de los números naturales.
  + int es el tipo de los números enteros.
  + real es el tipo de los números reales.

+ Funciones de conversión de tipo:
  #+BEGIN_EXAMPLE
  int         :: nat ⇒ int
  real        :: nat ⇒ real
  real_of_int :: int ⇒ real
  nat         :: int ⇒ nat
  floor       :: real ⇒ int
  ceiling     :: real ⇒ int
  #+END_EXAMPLE

+ Para usar los números reales se necesita importar la teoría ~Complex_Main~ en
  lugar de ~Main~.

+ Isabelle, con ~Complex_Main~, convierte los tipos automáticamente. Por
  ejemplo, \\
  "(3::int) + (2::nat)"  da "5" :: "int" 

+ Operaciones aritméticas
  + Las operaciones aritméticas están sobrecargadas.
  + Operaciones básicas:
    + binarias:
      ~+, −, ∗ :: 'a ⇒ 'a ⇒ 'a~
    + monaria:
      ~− :: 'a ⇒ 'a~
  + División para ~nat~ e ~int~:
    ~div, mod :: 'a ⇒ 'a ⇒ 'a~
  + División para ~real~: 
    ~/ :: 'a ⇒ 'a ⇒ 'a~
  + Potencia: 
    ~ˆ :: 'a ⇒ nat ⇒ 'a~
  + Exponenciación: 
    ~powr :: 'a ⇒ 'a ⇒ 'a~
  + Valor absoluto: 
    ~abs :: 'a ⇒ 'a~
    
** Resumen

+ Definiciones de tipos y de funciones:
  + *datatype* se usa para definir tipos de datos (posiblemente recursivos). 
  + *fun* se usa para definir funciones (posiblemente recursivas y con
    patrones sobre los constructores).

+ Métodos de demostración:
  + *(induction x)* aplica inducción estructural sobre la variable x cuyo tipo
    es recursivo.
  + *simp* aplica simplificaciones al objetivo actual.
  + *auto* aplica simplificaciones (y algunas otras transformaciones) a todos
    los objetivos.

+ Enunciado de propiedades:
  + *lemma* nombre: "..."
  + *lemma* nombre [simp]: "..."

+ Esquema general de pruebas:
  #+BEGIN_EXAMPLE
  lemma nombre: "..."
  apply (...)
  apply (...)
  ...
  done
  #+END_EXAMPLE

+ Finales de pruebas:
  + *done* para terminar la demostración
  + *oops* para abandonar la demostración
  + *sorry* para abandonar la demostración pero pudiendo usar el lema y
    demostrarlo posteriormente.

+ Los estados de prueba son de la forma
  | ⋀x1 ... xp. A ⟹ B  |
  donde
  | x1, ..., xp | son las variables locales |
  | A           | son los supuestos locales |
  | B           | es el subobjetivo actual  |
 
+ Supuestos múltiples
  |〚 A₁ ; ... ; Aₙ 〛 ⟹ B | 
  es una abreviatura de  
  | A₁ ⟹ ... ⟹ Aₙ ⟹ B |

* Definiciones de tipos y funciones

** Definiciones de tipos

+ Definiciones con datatype
  + El caso general de datatype es
    : datatype (α(1),...,α(n))t = C1 τ(1,1) ...τ(1,n(1))
    :                           | ...
    :                           | Ck τ(k,1) ...τ(k,n(k))
  + El tipo de los constructores es
    : C(i) :: τ(i,1) ⇒ ... ⇒ τ(i,n(i)) ⇒ (α(1),...,α(n))t
  + Los valores de los constructores son disjuntos: \\ 
    Si i ≠ j, entonces ~C(i) ... ≠ C(j) ...~
  + Los constructores son inyectivos:
    : (C(i) x1 ,,, x n = C(i) y1 ... yn) = 
    : (x1 = y1 ∧ ... xn = yn) 
  + Las definiciones de tipos recursivos con datatype genera reglas de
    inducción. 

+ Expresiones case
  + El caso general de expresiones case es
    : (case t of pat(1) ⇒ t(1) | ... | pat(n) ⇒ t(n))
  + Los paréntesis externos son obligatorios,
  + Si los patrones son complicados, también lo son las demostraciones
   
+ Demo: [[./T2_Demo_Arbol.thy][T2_Demo_Arbol.thy]].
