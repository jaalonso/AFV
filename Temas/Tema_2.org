#+TITLE: Tema 2: Programación y demostración
#+LANGUAGE: es

* Visión panorámica de Isabelle/HOL

** HOL: Lógica de orden superior

+ Las siglas HOL (del inglés, /Higher-Order Logic/) significa "Lógica de orden
  superior". 

+ Ecuación fundamental de HOL:
  + HOL = Programación funcional + Lógica

+ HOL, como lenguaje de programación, dispone de
  + operadores lógicos
  + funciones recursivas
  + funciones de orden superior
  + tipos de datos

+ Fórmulas de HOL:
  + Inicialmente sólo consideraremos ecuaciones de la forma ~t = s~ donde ~t~ y
    ~s~ son términos.
  + Más adelante se añadirán conectivas y cuantificadores.

** Tipos y términos 

+ Sintaxis de tipos
  : τ ::= (τ)
  :     | bool | nat | int ...    tipos básicos 
  :     | 'a | 'b | ...           variables de tipos
  :     | τ ⇒ τ                   funciones
  :     | τ × τ                   pares (en ASCII: *)
  :     | τ list                  listas
  :     | τ set                   conjuntos
  :     | ...                     tipos definidos por el usuario


+ Sintaxis de términos (del lambda cálculo)
  : t ::= (t)
  :     | a       constante o variable 
  :     | t t     aplicación de funciones
  :     | λx. t   abstracción de funciones
  :     | ...     azúcar sintática

+ Tipado de términos
  + Todos los términos tienen un tipos.
  + 
    ~t :: τ~ significa que "el tipo de ~t~ es ~τ~

+ Inferencia de tipo:
  + Regla de tipos para aplicaciones
    : t :: τ₁ ⇒ τ₂    u :: τ₁
    : ——————————————————————–
    :        t u :: t₂
  + Isabelle automáticamente calcula el tipo de las variables de los
    términos. Esto se llama *inferencia de tipos*.
  + A veces no es posible por la presencia de funciones /sobrecargadas/. 
  + Las ambigüedades se resuelven con *anotaciones de tipo*. Por ejemplo, 
    ~f (x::nat)~. 

+ Currificación:
  + Definición curryficada 
    ~f :: τ₁ ⇒ τ₂ ⇒ τ~ 
  + Definición cartesiana 
    ~g :: τ₁ × τ₂ ⇒ τ~ 

+ Azúcar sintáctica
  + Operadores infijos:
    ~+, -, *, #, @, ...~
  + Operadores mixfijos:
   ~if _ then _ else _, case _ of, ...~
  + Los prefijos tienen prioridad sobre los infijos
    + ~f x + y ≡ (f x) + y~
    + ~f x + y ≢ f (x + y)~
  + Las expresiones con ~if~ o ~case~ se tienen que escribir entre paréntesis. 

+ Teorías de Isabelle
  + Las teorías de Isabelle son análogas a los módulos de Haskell.
  + La sintaxis de una teoría de Isabelle es
    : theory T
    : imports T₁ ... Tₙ
    : begin
    : (definiciones, teoremas. demostraciones, ...)*
    : end
  + ~T~ es el nombre de la teoría (y el nombre de su fichero tiene que ser
    ~T.thy~)
  + ~T₁, ..., Tₙ~ son la teorías importadas.
  + La importación de toerías es transitiva.
  + El cuerpo de la teoría se compone de definiciones,
    teoremas. demostraciones, ... 
  + Usualmente importaremos sólo la teoría ~Main~.

+ Sintaxis concreta:
  + En la teorías se tiene que escribir entre dobles comillas los tipos, los
    términos y las fórmulas.
  + Una posible excepción son los identificadores simples.

** El entorno jEdit

+ Introducción
  + El editor de Isabelle está construido sobre jEdit.
  + Reconoce las teorías de Isabelle por su extensión (~.thy~). 
  + Procesa las teorías de forma síncrona.

+ Demo: [[./T2_Introduccion.thy][T2_Introduccion.thy]].
  + Comentarios 
  + Inferencia de tipo 
  + Evaluación de términos 
  + Ejemplos de sobrecarga 
  + Ejemplos de errores de tipo 

** Los tipos ~bool~, ~nat~ y ~list~

+ El tipo ~bool~
  + ~bool~ es el tipo de los booleanos
  + Está definido por \\
    ~datatype bool = True | False~
  + Funciones predefinidas: \\
    ~∧, ∨, →, ... :: bool ⇒ bool ⇒ bool~
  + Las *fórmulas* son los términos de tipo ~bool~.
  + El bicondicional es ~=~.   

+ El tipo ~nat~
  + ~nat~ es el tipo de los números naturales.
  + Está definido por \\
    ~datatype nat = 0 | Suc nat~
  + Ejemplos de valores de tipo ~nat~
    ~0, Suc 0, Suc (Suc 0), ...~
  + Funciones predefinidas \\
    ~+, ∗, ... :: nat ⇒ nat ⇒ nat~    
  + Los números y las operaciones aritméticas están sobrecargadas: \\
    + 
      ~0, 1, 2, ... :: 'a~ 
    + 
      ~+ :: 'a ⇒ 'a ⇒ 'a~ 
  + Para resolver las ambigüedades se usan anotaciones:
    ~1::nat, x + (y::nat)~
  + Demo: [[./T2_Demo_Nat.thy][T2_Demo_Nat.thy]].
    + Ejemplo de definición recursiva sobre los naturales: suma.
    + Ejemplo de demostración pos inducción sobre los naturales. 
 
+ El tipo ~'a list~
  + ~'a list~ es el tipo de las listas con elementos de tipo ~'a~.
  + Está definido por \\
    ~datatype 'a list = Nil | Cons 'a ('a list)~
  + Ejemplos listas: 
    ~Nil, Cons 1 Nil, Cons 1 (Cons 2 Nil), ...~
  + Azúcar sintáctica:
    + ~[]~ es una abreviatura de ~Nil~ (la lista vacía).
    + ~x#xs~ es una abreviatura de ~Cons x xs~ (la lista cuyo primer elemento
      es ~x~ y su resto es ~xs~).
    + ~[x1,...,xn]~ es una abreviatura de ~x1 # (x2 #...# (xn # []))~ (la lista
      cuyos elementos son ~x1~, ..., ~xn~).
    + Esquema de inducción sobre listas: Para probar que todas las listas
      cumplen una propiedad P, basta probar que
      + P([])
      + si P(xs) entonces P(x#xs), para todos x, xs.
    + Demo: [[./T2_Demo_Lista.thy][T2_Demo_Lista.thy]].
      + El tipo de las listas.
      + Funciones sobre listas: conc e inversa.
      + Ejemplo de búqueda descendente de la demostración de 
        "inversa (inversa xs) = xs".

     
